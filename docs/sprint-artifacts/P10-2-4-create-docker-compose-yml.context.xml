<story-context id="P10-2.4" v="1.0">
  <metadata>
    <epicId>P10-2</epicId>
    <storyId>4</storyId>
    <title>Create docker-compose.yml</title>
    <status>drafted</status>
    <generatedAt>2025-12-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/P10-2-4-create-docker-compose-yml.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>to deploy ArgusAI with a single docker-compose command</iWant>
    <soThat>setup is simple and quick</soThat>
    <tasks>
      <task id="1" status="pending">
        Create docker-compose.yml at project root
        <subtasks>
          <subtask id="1.1">Define backend service with build context, image reference, ports, and environment</subtask>
          <subtask id="1.2">Define frontend service with build context, image reference, ports, and depends_on</subtask>
          <subtask id="1.3">Configure NEXT_PUBLIC_API_URL build arg for internal Docker network communication</subtask>
        </subtasks>
      </task>
      <task id="2" status="pending">
        Configure named volumes for data persistence
        <subtasks>
          <subtask id="2.1">Create argusai-data volume and mount to backend /app/data</subtask>
          <subtask id="2.2">Document volume persistence behavior in comments</subtask>
        </subtasks>
      </task>
      <task id="3" status="pending">
        Configure internal networking
        <subtasks>
          <subtask id="3.1">Create argusai-net bridge network</subtask>
          <subtask id="3.2">Attach all services to argusai-net</subtask>
        </subtasks>
      </task>
      <task id="4" status="pending">
        Add health checks for container orchestration
        <subtasks>
          <subtask id="4.1">Add backend health check using /health endpoint</subtask>
          <subtask id="4.2">Add frontend health check using wget</subtask>
          <subtask id="4.3">Configure depends_on with condition: service_healthy</subtask>
        </subtasks>
      </task>
      <task id="5" status="pending">
        Configure restart policies
        <subtasks>
          <subtask id="5.1">Set restart: unless-stopped for all services</subtask>
        </subtasks>
      </task>
      <task id="6" status="pending">
        Test and validate docker-compose configuration
        <subtasks>
          <subtask id="6.1">Run docker-compose config to validate syntax</subtask>
          <subtask id="6.2">Document testing steps in story notes</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">
      <given>I have Docker and docker-compose installed</given>
      <when>I run `docker-compose up -d`</when>
      <then>both backend and frontend containers start and the application is accessible at localhost with data persisted in named volumes</then>
    </criterion>
    <criterion id="AC2">
      <given>the containers are running</given>
      <when>I run `docker-compose down` then `docker-compose up`</when>
      <then>containers stop gracefully, volumes are preserved, and previous state is restored</then>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-P10-2.md</path>
        <title>Epic P10-2 Technical Specification</title>
        <section>Story P10-2.4: docker-compose.yml</section>
        <snippet>Defines services: backend, frontend with build contexts, named volumes (argusai-data), bridge network (argusai-net), health checks, and restart policies. Default ports: 8000 (backend), 3000 (frontend).</snippet>
      </doc>
      <doc>
        <path>docs/epics-phase10.md</path>
        <title>Phase 10 Epic Breakdown</title>
        <section>Story P10-2.4: Create docker-compose.yml</section>
        <snippet>Acceptance criteria for single docker-compose up command to start complete stack with data persistence in named volumes.</snippet>
      </doc>
      <doc>
        <path>docs/PRD-phase10.md</path>
        <title>Phase 10 PRD</title>
        <section>FR19</section>
        <snippet>Single `docker-compose up` starts complete stack with backend and frontend services.</snippet>
      </doc>
      <doc>
        <path>.env.example</path>
        <title>Docker Environment Example</title>
        <section>Full file</section>
        <snippet>Comprehensive environment configuration including required (ENCRYPTION_KEY, JWT_SECRET_KEY), database, application, frontend, SSL, AI providers, push notifications, HomeKit, and MQTT settings.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>backend/Dockerfile</path>
        <kind>dockerfile</kind>
        <symbol>Backend container build</symbol>
        <lines>1-81</lines>
        <reason>Backend Dockerfile that docker-compose will build from. Multi-stage build with Python 3.11, ffmpeg, health check on /health, VOLUME /app/data, port 8000.</reason>
      </artifact>
      <artifact>
        <path>frontend/Dockerfile</path>
        <kind>dockerfile</kind>
        <symbol>Frontend container build</symbol>
        <lines>1-82</lines>
        <reason>Frontend Dockerfile with Node 20 alpine, standalone output mode, NEXT_PUBLIC_API_URL build arg, health check via wget, port 3000.</reason>
      </artifact>
      <artifact>
        <path>frontend/next.config.ts</path>
        <kind>config</kind>
        <symbol>nextConfig</symbol>
        <lines>1-31</lines>
        <reason>Next.js config with standalone output enabled for Docker, rewrites for API proxy to backend.</reason>
      </artifact>
      <artifact>
        <path>backend/app/core/config.py</path>
        <kind>config</kind>
        <symbol>Settings</symbol>
        <lines>all</lines>
        <reason>Backend configuration with environment variable handling. ENCRYPTION_KEY required, DATABASE_URL defaults to sqlite:///data/app.db.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package>fastapi</package>
        <package>uvicorn</package>
        <package>sqlalchemy</package>
        <package>alembic</package>
        <package>python-multipart</package>
        <package>cryptography</package>
        <package>opencv-python-headless</package>
        <package>pyav</package>
        <package>psycopg2-binary</package>
      </python>
      <node>
        <package>next@15</package>
        <package>react@19</package>
        <package>@tanstack/react-query</package>
        <package>tailwindcss</package>
      </node>
      <system>
        <package>Docker Engine 24.0+</package>
        <package>Docker Compose 2.20+</package>
      </system>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="pattern">docker-compose version 3.8 format</constraint>
    <constraint type="pattern">Named volumes for persistence (not bind mounts in production)</constraint>
    <constraint type="pattern">Internal Docker network for service communication</constraint>
    <constraint type="pattern">Health-based service dependencies</constraint>
    <constraint type="pattern">Non-root users in containers (already implemented in Dockerfiles)</constraint>
    <constraint type="security">No secrets baked into images - use environment variables</constraint>
    <constraint type="security">ENCRYPTION_KEY must be required (fail without it)</constraint>
    <constraint type="environment">NEXT_PUBLIC_API_URL must be passed as build arg (baked at build time)</constraint>
    <constraint type="environment">Environment variables loaded from .env file at project root</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>Backend Health Check</name>
      <kind>REST endpoint</kind>
      <signature>GET /health -> 200 OK</signature>
      <path>backend/main.py or backend/app/api/v1/system.py</path>
    </interface>
    <interface>
      <name>Frontend Health Check</name>
      <kind>HTTP endpoint</kind>
      <signature>GET / -> 200 OK (Next.js homepage)</signature>
      <path>frontend/ (Next.js default)</path>
    </interface>
    <interface>
      <name>Docker Compose Services</name>
      <kind>docker-compose service</kind>
      <signature>backend:8000, frontend:3000</signature>
      <path>docker-compose.yml</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Docker Compose validation using `docker-compose config` to verify YAML syntax. Integration testing by starting services and verifying health endpoints respond. Volume persistence tested by stopping/starting containers and checking data retention.
    </standards>
    <locations>
      <location>Manual testing commands in story notes</location>
      <location>docker-compose config (syntax validation)</location>
    </locations>
    <ideas>
      <idea ac="AC1">Test docker-compose up -d starts both containers successfully</idea>
      <idea ac="AC1">Test http://localhost:8000/health returns 200</idea>
      <idea ac="AC1">Test http://localhost:3000 loads frontend</idea>
      <idea ac="AC1">Test named volume argusai-data is created</idea>
      <idea ac="AC2">Test docker-compose down stops containers gracefully</idea>
      <idea ac="AC2">Test docker volume ls shows argusai-data persisted</idea>
      <idea ac="AC2">Test docker-compose up restores previous state</idea>
    </ideas>
  </tests>
</story-context>
