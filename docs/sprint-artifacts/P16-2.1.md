# Story P16-2.1: Research and Design Streaming Approach

Status: done

## Story

As a **developer**,
I want **to understand uiprotect streaming capabilities**,
So that **I can implement the best streaming approach for live camera viewing**.

## Acceptance Criteria

1. **Given** the uiprotect library documentation
   **When** I research streaming options
   **Then** I document findings for: WebSocket streaming, RTSP proxy, HLS conversion, MJPEG fallback

2. **Given** the research findings
   **When** I evaluate options against requirements (<3s latency, browser compatibility)
   **Then** I recommend an approach with rationale

3. **And** create a technical design document in `docs/sprint-artifacts/p16-2-1-streaming-design.md`
   **And** document: chosen approach, libraries needed, bandwidth estimates, browser support matrix

## Tasks / Subtasks

- [x] Task 1: Research uiprotect streaming capabilities (AC: 1)
  - [x] Review uiprotect library documentation for streaming APIs
  - [x] Identify `get_camera_video()` or similar methods
  - [x] Check for WebRTC support in uiprotect
  - [x] Document RTSP URL access methods

- [x] Task 2: Evaluate streaming options (AC: 2)
  - [x] WebSocket streaming: pros/cons, latency, complexity
  - [x] RTSP proxy: direct stream forwarding approach
  - [x] HLS conversion: ffmpeg transcoding to HLS segments
  - [x] MJPEG fallback: frame-by-frame JPEG streaming
  - [x] Create comparison matrix

- [x] Task 3: Analyze browser compatibility (AC: 2)
  - [x] Test/research browser support for each approach
  - [x] Document Safari, Chrome, Firefox, Edge support
  - [x] Consider mobile browser limitations

- [x] Task 4: Estimate bandwidth and latency (AC: 3)
  - [x] Calculate bandwidth per quality level
  - [x] Estimate latency for each approach
  - [x] Document concurrent stream capacity

- [x] Task 5: Create design document (AC: 3)
  - [x] Write `docs/sprint-artifacts/p16-2-1-streaming-design.md`
  - [x] Include: chosen approach, libraries needed
  - [x] Include: bandwidth estimates, browser support matrix
  - [x] Include: implementation recommendations

## Dev Notes

### Technical Context

- **Epic**: P16-2 - Live Camera Streaming
- **GitHub Issue**: #336
- **FRs Covered**: FR16-FR22

### Key Requirements

- **FR17**: Live stream displays with <3 second latency
- **FR18**: Users can select stream quality
- **FR19**: Users can view stream in fullscreen
- **FR20**: System falls back to snapshot if stream unavailable
- **FR21**: Multiple cameras can stream simultaneously

### uiprotect Library Context

The uiprotect library is already used in ArgusAI for:
- WebSocket event subscription (motion, smart detection)
- Snapshot retrieval (`get_snapshot()`)
- Camera discovery and management

Research should focus on video streaming APIs available in uiprotect.

### Browser Streaming Options to Research

1. **WebSocket + Canvas**: Stream raw frames via WebSocket, render to canvas
2. **HLS (HTTP Live Streaming)**: Transcode to HLS with ffmpeg, use hls.js
3. **WebRTC**: Peer-to-peer streaming if uiprotect supports
4. **MJPEG**: Motion JPEG stream (simple but limited)
5. **MSE (Media Source Extensions)**: fMP4 streaming

### References

- [Source: docs/epics-phase16.md#Epic-P16-2]
- [Source: docs/PRD-phase16.md#Live-Camera-Streaming]
- [uiprotect GitHub](https://github.com/uilibs/uiprotect)

## Dev Agent Record

### Context Reference

<!-- Path(s) to story context XML will be added here by context workflow -->

### Agent Model Used

Claude Opus 4.5

### Debug Log References

### Completion Notes List

1. **uiprotect Capabilities Documented**:
   - `get_camera_snapshot()` - single frame capture
   - `get_camera_video(start, end)` - video clip download
   - `subscribe_websocket()` - event notifications only
   - RTSP direct access via `rtsp://host:7447/{camera_id}`
   - No native browser-compatible streaming API

2. **Recommended Approach**: MJPEG via WebSocket
   - Ultra-low latency (~100ms) exceeds FR17 (<3s) requirement
   - Universal browser support without plugins
   - Leverages existing OpenCV/PyAV infrastructure
   - HLS with hls.js for recorded playback

3. **Key Design Decisions**:
   - 3 quality levels (Low/Medium/High)
   - Max 8 concurrent streams per server
   - WebSocket binary frames for efficiency
   - Snapshot polling fallback (FR20)

4. **No New Backend Dependencies Required**:
   - OpenCV (existing) for frame extraction
   - PyAV (existing) for secure RTSP
   - FastAPI WebSockets (existing)
   - Only hls.js needed on frontend for recorded playback

### File List

- `docs/sprint-artifacts/p16-2-1-streaming-design.md` (NEW) - Technical design document
- `docs/sprint-artifacts/P16-2.1.md` (MODIFIED) - Story file updated

## Change Log

| Date | Change | Author |
|------|--------|--------|
| 2026-01-01 | Story created | Claude Code |
| 2026-01-01 | Research completed, design document created, story marked done | Claude Code |
